<?xml version="1.0" encoding="utf-8"?>
<FxApplication xmlns="http://ns.adobe.com/mxml/2009" 
	backgroundColor="#000000" applicationComplete="init()">
	
	<!-- In the interest of keeping this sample contained in a single file, the styles are all here: -->
	<Style>

		global {
		   color: #FFFFFF;
		   fontFamily: "Verdana";
		   fontSize: 11px;
		   fontWeight: normal;
		}
		
		.title {
			fontSize: 20px;
			fontWeight: normal;
		}
				
		.smallLabel {
			fontSize: 9px;
			color: #aaaaaa;
		}
						
		Button {
			themeColor: "haloSilver";
		}
				
		HSlider {
			themeColor: "haloSilver";
            dataTipStyleName: "dataTip";
            dataTipOffset: 6;
        }

        .dataTip {
            backgroundColor: black;
        }
        
        ToolTip {
        	backgroundColor: black;
        }
        
        TextInput {
        	color: #333333;
        	themeColor: "haloSilver";
        }

		TextArea {
        	color: #333333;
        	themeColor: "haloSilver";
        }
        
        CheckBox {
        	color: #ffffff;
			textRollOverColor: #cccccc;
			textSelectedColor: #ffffff;        	
        	themeColor: "haloSilver";
        }

        .transitionInfoContainerStyle {
			paddingBottom: 5;
			paddingLeft: 5;
			paddingRight: 5;
			paddingTop: 5;
			alpha: 0;
			background-color: #000000;
			background-alpha: 0.5;
        }
                
	</Style>
	
	
	<Script>
		<![CDATA[	
			import mx.core.UIComponent;
			import mx.events.SliderEvent;
			import mx.controls.Alert;
			
			import org.openvideoplayer.events.*;
			import org.openvideoplayer.net.*;
			import org.openvideoplayer.rss.*;
			import org.openvideoplayer.parsers.*;
			
			import com.akamai.net.*
					
			// Define private variables
			private var _nc:AkamaiConnection;
			private var _ns:AkamaiDynamicNetStream;
			private var _smilMetafile:DynamicSmilParser; 
			private var _sliderDragging:Boolean;
			private var _waitForSeek:Boolean;
			private var _video:Video;
			private var _videoHolder:UIComponent;
			private var _hasEnded:Boolean;
			private var _videoSettings:Object;
			private var _streamLength:Number;
			private var _transitionMsgTimer:Timer;
			private var _lastSwitch:int;
			
			private const _DEFAULT_SMIL_FILE_:String = "http://mediapm.edgesuite.net/ovp/content/demo/smil/elephants_dream.smil";
			private const _SWITCH_REQUEST_MSG_:String = "Requesting switch...";
			private const _SWITCH_UNDERWAY_MSG_:String = "Starting stream transition...";
			private const _SWITCH_COMPLETE_MSG_:String = "Stream transition complete.";
			private const _STREAM_TRANSITION_AT_HIGHEST_:String = "Already playing the highest quality stream.";
			private const _STREAM_TRANSITION_AT_LOWEST_:String = "Already playing the lowest quality stream.";
			private const _TRANSITION_MSG_DISPLAY_TIME_:int = 2000;
			
			private function init():void {		
				stage.addEventListener(FullScreenEvent.FULL_SCREEN, handleReturnFromFullScreen);

				_smilMetafile = new DynamicSmilParser();
				_smilMetafile.addEventListener(OvpEvent.PARSED,bossParsedHandler);
				_smilMetafile.addEventListener(OvpEvent.ERROR,errorHandler);

				_nc = new AkamaiConnection();
				_nc.addEventListener(OvpEvent.ERROR,errorHandler);
				_nc.addEventListener(NetStatusEvent.NET_STATUS,netStatusHandler);
				
				addVideoToStage();
				
				_transitionMsgTimer = new Timer(_TRANSITION_MSG_DISPLAY_TIME_);
				_transitionMsgTimer.addEventListener(TimerEvent.TIMER, onTransitionMsgTimer);
				
				var pt:Point = videoWindow.contentToGlobal(new Point(videoWindow.x, videoWindow.y));
				pt = transitionInfoContainer.globalToContent(pt);
				transitionInfoContainer.x = pt.x;
				transitionInfoContainer.y = pt.y + videoWindow.height - transitionInfoContainer.height ;
				
				_lastSwitch = 0;
			}
				
			// Handles the notification that the BOSS feed was successfully parsed
			private function bossParsedHandler(e:OvpEvent):void {
				write("SMIL parsed successfully:");
				write("  Host name: " + _smilMetafile.hostName);
				write("  Stream name: " + _smilMetafile.streamName);

				// Establish the connection
				_nc.connect(_smilMetafile.hostName); 
			}
			
			// Commences connection to a new link
			private function startPlayback():void {
				output.text = "";
				bPlayPause.enabled = false;
				bFullscreen.enabled = false;
				_hasEnded = false;
				multiBRCtrls.visible = false;

				// Clean up from previous session, if it exists
				if (_nc.netConnection is NetConnection) {
					_ns.useFastStartBuffer = false;
					_nc.close();
				}

				// Start parsing the SMIL file
				_smilMetafile.load(bossLink.text)				
			}
			
			// Once a good connection is found, this handler will be called
			private function connectedHandler():void {
				_ns = new AkamaiDynamicNetStream(_nc);
				_ns.addEventListener(OvpEvent.ERROR,errorHandler);
				_ns.addEventListener(OvpEvent.DEBUG, debugMsgHandler);
				_ns.addEventListener(OvpEvent.COMPLETE,completeHandler); 
				_ns.addEventListener(OvpEvent.PROGRESS,update); 
				_ns.addEventListener(NetStatusEvent.NET_STATUS,streamStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS,streamPlayStatusHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_METADATA,metadataHandler);
				_ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT,cuepointHandler);	
				_ns.addEventListener(OvpEvent.SUBSCRIBE_ATTEMPT, handleSubscribeAttempt);		
				_ns.isLive = true;
				_ns.maxBufferLength = 10;
				_video.visible = false;
				_video.attachNetStream(_ns);
				write("Successfully connected to: " + _nc.netConnection.uri);
				write("Port: " + _nc.actualPort);
				write("Protocol: " + _nc.actualProtocol);
				write("Server IP address: " + _nc.serverIPaddress);
				_ns.play(_smilMetafile.dsi);
			}
			
			// Handles all error events
			private function errorHandler(e:OvpEvent):void {
				switch(e.data.errorNumber) {
					case OvpError.INVALID_INDEX:
						handleInvalidIndexError();
						break;
					case OvpError.STREAM_NOT_FOUND:
						Alert.show("Connected to the server at " + _nc.serverIPaddress + " but timed-out trying to locate the live stream " + _smilMetafile.streamName, "UNABLE TO FIND STREAM ", Alert.OK);
						break;
					default:
						Alert.show("Error #" + e.data.errorNumber+": " + e.data.errorDescription, "ERROR", Alert.OK);
						break;
				}
			}
			
			// Receives all status events dispatched by the active NetConnection
			private function netStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);
				switch (e.info.code) {
					case "NetConnection.Connect.Rejected":
						write("Rejected by server. Reason is "+e.info.description);
						break;
					case "NetConnection.Connect.Success":
						connectedHandler();
						break;
				}
			}
			
			// Receives all status events dispatched by the active NetStream
			private function streamStatusHandler(e:NetStatusEvent):void {
				write(e.info.code);	
				switch (e.info.code) {
					case "NetStream.Buffer.Full":
						// _waitForSeek is used to stop the scrubber from updating
						// while the stream transtions after a seek
						_waitForSeek = false;
						break;
					case "NetStream.Play.Transition":
						showTransitionMsg(_SWITCH_UNDERWAY_MSG_);
						break;		
					case "NetStream.Play.Start":
							bPlayPause.enabled = true;
							bFullscreen.enabled = true;
						break;				
				}
			}
			
			// Receives all onPlayStatus events dispatched by the active NetStream
			private function streamPlayStatusHandler(e:OvpEvent):void {
				if (e.data.code == "NetStream.Play.TransitionComplete") {
					multiBRCtrls.visible = true;
					showTransitionMsg(_SWITCH_COMPLETE_MSG_, _TRANSITION_MSG_DISPLAY_TIME_);
				}
				write(e.data.code);
			}
					
			// Handle a resubscribe attempt
			private function handleSubscribeAttempt(e:OvpEvent):void {
				write("Trying to re-subscribe to the live stream ...");
			}
			// Receives all onMetadata events dispatched by the active NetStream
			private function metadataHandler(e:OvpEvent):void {
				write("========== Metadata found in stream  ===========");
				for (var propName:String in e.data) {
					write("  "+propName+" = "+e.data[propName]);
				}
				write("========== End of Stream Metadata  ===========");
				// Adjust the video dimensions on the stage if they do not match the metadata
				if ((Number(e.data["width"]) != _video.width)  || (Number(e.data["height"]) != _video.height)) {
					scaleVideo(Number(e.data["width"]),Number(e.data["height"]));
				}
			}
			
			// Scales the video to fit into the window while preserving aspect ratio.
			private function scaleVideo(w:Number,h:Number):void {
				if (w/h >= 4/3) {
					_video.width = 480;
					_video.height = 480*h/w;
				} else {
					_video.width = 360*w/h;
					_video.height = 360;
				}
				_video.x = (_videoHolder.width-_video.width)/2;
				_video.y = (_videoHolder.height-_video.height)/2;
				_video.visible = true;
			}
			
			// Receives all cuepoint events dispatched by the active NetStream
			private function cuepointHandler(e:OvpEvent):void {
				for (var propName:String in e.data) {
						if (propName != "parameters") {
							write(propName+" = "+e.data[propName]);
						} else {
							write("parameters =");
							if (e.data.parameters != undefined) {
								for (var paramName:String in e.data.parameters) {
									write(" "+paramName+": "+e.data.parameters[paramName]);
								}
							} else {
								write("undefined");
							}
						}
					}
			}
						
			// Handles the stream length response after a request to requestStreamLength
			private function streamLengthHandler(e:OvpEvent):void {
				write("Stream length is " + e.data.streamLength);
				bPlayPause.enabled = true;
				bFullscreen.enabled = true;
				_streamLength = e.data.streamLength;
				
			}
			
			// Receives information that stream playback is complete. This notification
			// should not be used when playing back progressive content as the Flash client
			// does not dispatch the NetStream.onPlayStatus event on which this notification is based.
			private function completeHandler(e:OvpEvent):void {
				write("Stream is complete");
				_hasEnded = true;
				bPlayPause.label = "PLAY";
			}
			
			// Attaches the video to the stage
			private function addVideoToStage():void {
				_videoHolder= new UIComponent();
				_video = new Video(480, 270);
				_video.smoothing = true;
				_video.visible = false;
				_video.x = (_videoHolder.width-_video.width) / 2;
				_video.y = (_videoHolder.height-_video.height) / 2;
				_videoHolder.addChild(_video);
        		videoWindow.addChild(_videoHolder);
   			}
   			   			
   			// Updates the time display and slider
   			private function update(e:OvpEvent):void {
   				timeDisplay.text = _ns.timeAsTimeCode + "| LIVE";
   			}
   			
   			// Handles play and pause
   			private function doPlayPause():void {
   				switch (bPlayPause.label){
   					case "PAUSE":
   						bPlayPause.label = "PLAY";
   						_ns.pause();
   					break;
   					case "PLAY":
   						bPlayPause.label = "PAUSE";
   						if (_hasEnded) {
   							_hasEnded = false;
							_ns.play(_smilMetafile.dsi);
   						} else {
   							_ns.resume();
   						}
   					break;
   				}
   			}
   			
   			// Formats the slider dataTip
			private function showVolume(val:String):String {
				return ("Volume: "+Math.round(Number(val)*100)+"%");
			}
			
			// Converts time to timecode
			private function showScrubTime(val:String):String {
	   			var sec:Number = Number(val);
				var h:Number = Math.floor(sec/3600);
				var m:Number = Math.floor((sec%3600)/60);
				var s:Number = Math.floor((sec%3600)%60);
				return (h == 0 ? "":(h<10 ? "0"+h.toString()+":" : h.toString()+":"))+(m<10 ? "0"+m.toString() : m.toString())+":"+(s<10 ? "0"+s.toString() : s.toString());
			}
			
			// Changes the stream volume
			private function changeVolume(event:SliderEvent):void {
				if (_ns) 
					_ns.volume = event.value;
			}
			
			// Writes trace statements to the output display
			private function write(msg:String):void {
				output.text += msg + "\n";
				callLater(autoScroll);
			}
			
			private function debugMsgHandler(event:OvpEvent):void {
				write(String(event.data));	
			}
			
			private function autoScroll():void {
				output.verticalScrollPosition = output.maxVerticalScrollPosition;
			}
			
			// Switches to full screen mode
			private function switchToFullScreen():void {
			    // when going out of full screen mode 
			    // we use these values
			    _videoSettings = new Object();
			    _videoSettings.savedWidth = _videoHolder.width;
			    _videoSettings.savedHeight = _videoHolder.height;
			    _videoSettings.x = _videoHolder.x;
			    _videoSettings.y = _videoHolder.y;
			    try {
			    stage["fullScreenSourceRect"] = new Rectangle(0,0, _video.videoWidth ,_video.videoHeight);	 
			    stage["displayState"] = StageDisplayState.FULL_SCREEN;
			    videoWindow.removeChild(_videoHolder);
			    addChild(_videoHolder);
			    mainContainer.visible = false;
			   	_video.x = _videoHolder.x = 0;
			   	_video.y = _videoHolder.y = 0;
			    _video.width =  _videoHolder.width = _video.videoWidth;
			    _video.height =  _videoHolder.height = _video.videoHeight;
			    _video.width =  _videoHolder.width = _video.videoWidth;
			    _video.height =  _videoHolder.height = _video.videoHeight;
			    _video.smoothing = false;
			    }
			    catch (e:Error) {
			    	write("Fullscreen mode has not been enabled by the HTML wrapper");
			    }
			}
			
			// Handles the return from fullscreen
			private function handleReturnFromFullScreen(e:FullScreenEvent):void {
				if (!e.fullScreen) {
					removeChild(_videoHolder);
					videoWindow.addChild(_videoHolder);
				    _video.smoothing = true;
				    _videoHolder.width = _videoSettings.savedWidth;
				    _videoHolder.height = _videoSettings.savedHeight;
				    _videoHolder.x = _videoSettings.x
				   	_videoHolder.y = _videoSettings.y
				    scaleVideo(_video.videoWidth,_video.videoHeight);
				    mainContainer.visible = true;
				    
				}
			}
				
			private function onClickMultiBitRateAuto(event:MouseEvent):void {
				if (_ns) {
					_ns.useManualSwitchMode(!chkboxAuto.selected);					
				}
				bSwitchDown.visible = bSwitchUp.visible = !chkboxAuto.selected;
			}
			
			private function onClickSwitchDown(event:MouseEvent):void {
				showTransitionMsg(_SWITCH_REQUEST_MSG_);
				_lastSwitch = -1;					
				_ns.switchDown();
			}
			
			private function onClickSwitchUp(event:MouseEvent):void {
				showTransitionMsg(_SWITCH_REQUEST_MSG_);
				_lastSwitch = 1;					
				_ns.switchUp();
			}
			
			private function handleInvalidIndexError():void {
				if (_lastSwitch > 0) {
					showTransitionMsg(_STREAM_TRANSITION_AT_HIGHEST_, _TRANSITION_MSG_DISPLAY_TIME_);
				}
				else if (_lastSwitch < 0) {
					showTransitionMsg(_STREAM_TRANSITION_AT_LOWEST_, _TRANSITION_MSG_DISPLAY_TIME_);
				}
			}
			
			private function showTransitionMsg(msg:String, _time:Number=0):void {
				transitionLabel.text = msg;
								
				transitionInfoContainer.visible = true;
				
				if (_time > 0) {
					_transitionMsgTimer.delay = _time;
					_transitionMsgTimer.start();
				}
				enableSwitchButtons(false);
			}
			
			private function hideTransitionMsg():void {
				transitionLabel.text = "";
				_transitionMsgTimer.stop();
				transitionInfoContainer.visible = false;
				enableSwitchButtons();							
			}
						
			private function onTransitionMsgTimer(event:TimerEvent):void {
				hideTransitionMsg();
			}
			
			private function enableSwitchButtons(_enable:Boolean=true):void {
				bSwitchDown.enabled = bSwitchUp.enabled = _enable;
			}
			
		]]>
	</Script>
	
	<VBox id="mainContainer" paddingLeft="20" paddingTop="20">
		<Label text="Flash Video Live Multi-Bit Rate Reference Player" styleName="title"/>
	    <HBox>
			<TextInput id="bossLink" text="{_DEFAULT_SMIL_FILE_}" width="547" />
			<Button id="bStart" label="Load" click="startPlayback()"/>
	    </HBox>
	    <HBox paddingTop="20">
			<VBox>
				<Label text="Status:"/>
				<TextArea width="420" height="372" id="output"/>
			</VBox>
			<Spacer width="20" />
			<VBox id="container2" paddingBottom="6" backgroundColor="#333333" height="100%" width="100%" horizontalAlign="center" verticalAlign="middle">
			  <HBox width="480" height="360" id="videoWindow" borderStyle="none" verticalAlign="middle" horizontalAlign="center" backgroundColor="#242424"/>   	
			  	<ApplicationControlBar width="480" id="applicationcontrolbar1">
			  	     <Button id="bPlayPause" label="PAUSE" click="doPlayPause()" enabled="false"/>
			  	     <Button id="bFullscreen" label="FULLSCREEN" click="switchToFullScreen()"  enabled="false"/>
			  	     <HSlider width="46" height="20" id="volumeSlider" value="100" dataTipFormatFunction="showVolume" minimum="0" maximum="1" 
			  	     	change="changeVolume(event)" allowTrackClick="true" liveDragging="true"/>
			  	     <Text id="timeDisplay" text="00:00|00:00"/>
			  	     <HBox id="multiBRCtrls" visible="false">
				  	     <CheckBox id="chkboxAuto" selected="true" label="Auto" toolTip="Toggle auto switching" click="onClickMultiBitRateAuto(event)" />
				  	     <Button id="bSwitchDown" label="-" width="32" toolTip="Switch Down" visible="false" click="onClickSwitchDown(event)" />
				  	     <Button id="bSwitchUp" label="+" width="32" toolTip="Switch Up" visible="false" click="onClickSwitchUp(event)" />
			  	     </HBox>
			  	</ApplicationControlBar>
			</VBox>
		</HBox>
	</VBox>
	<HBox id="transitionInfoContainer" styleName="transitionInfoContainerStyle" visible="false" width="480" horizontalAlign="right">
		<Label id="transitionLabel" />							
	</HBox>

</FxApplication>
